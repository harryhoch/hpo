<!DOCTYPE html>
<head>
<style>

svg {
font: 10px sans-serif;
}


</style>

<script src="https://d3js.org/d3.v4.min.js"></script>

</head>

<body>

<svg id= "treemapSvg" width="960" height="570"></svg>


<script>

var svg = d3.select("#treemapSvg");
var width = +svg.attr("width");
var height = +svg.attr("height");

var fader = function(color) { 
    return d3.interpolateRgb(color, "#fff")(0.2); 
};

// This one only generates 20 categorical colors, we need more than 20
var color = d3.scaleOrdinal(d3.schemeCategory20.map(fader));

// Creates a new treemap layout
var treemap = d3.treemap()
    .tile(d3.treemapResquarify) // This is the default with the golden ratio
    .size([width, height])
    .round(true)
    .paddingInner(1);

d3.json("treemap.json", function(error, data) {
    if (error) throw error;

	// this is the treemap.json data
	console.log(data);

    // Constructs a root node from the specified hierarchical data.
    var root = d3.hierarchy(data);

	// The returned node and each descendant has the following properties: data, depth, height, parent, children, value
	console.log(root);

    // https://github.com/d3/d3-hierarchy/#node_each
    root.each(function(d) { 
        if (d.depth > 0) {
          d.children = [];
          d.data.children = [];
        }
    });

	console.log(root);

	var newRoot = d3.hierarchy(root)
        .sum(sumByCount)
        .sort(function(a, b) { 
            // sort nodes by descending height (greatest distance from any descendant leaf) and then descending value
            return b.height - a.height || b.value - a.value; 
        });

    // Lays out the specified root hierarchy
    // You must call root.sum before passing the hierarchy to the treemap layout. 
    // You probably also want to call root.sort to order the hierarchy before computing the layout.
    // Also assigns the following properties on root and its descendants: x0, y0, x1, y1
    treemap(newRoot);

    console.log(newRoot.leaves());

    var node = svg.selectAll(".node")
        .data(newRoot.leaves())// Use the newRoot to render
        .enter().append("g")
        .attr("id", function(d) { return d.data.data.id; })
        .attr("class", "node")
        .attr("transform", function(d) { return "translate(" + d.x0 + "," + d.y0 + ")"; });

    node.append("rect")
		.attr("id", function(d) { return d.data.id; })
		.attr("width", function(d) { return d.x1 - d.x0; })
		.attr("height", function(d) { return d.y1 - d.y0; })
		.attr("fill", function(d) { return color(d.data.data.id); });

    // Text of each rectangle
    node.append("text")
        .attr("class", "node-name")
        .selectAll("tspan")
        .data(function(d) { return d.data.data.name.split(' '); }) // one word per line
        .enter().append("tspan")
        .attr("x", 5)
        .attr("y", function(d, i) { return 15 + i * 10; })
        .text(function(d) { 
            return d; 
        });

    // Show title toltip (full phenotype name and [id]) on mouse over. 
    node.append("title")
        .text(function(d) { return d.data.data.name + ' [' + d.data.data.id + ']'; });

});

function sumByCount(d) {
    return (d.children.length > 0) ? 0 : 1;
}

</script>

</body>

</html>