<!DOCTYPE html>
<head>
<style>

svg {
font: 10px sans-serif;
}

</style>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>

</head>

<body>

<svg id= "treemapSvg" width="960" height="570"></svg>

<script>

var svg = d3.select("#treemapSvg");
var width = svg.attr("width");
var height = svg.attr("height");

var navArr = [];

// A list of HP Ids from a patient with undiagnoised disease
var patientPhenotypes = [
    "HP_0012537",
    "HP_0000174",
    "HP_0000194",
    "HP_0000218",
    "HP_0000238",
    "HP_0000244",
    "HP_0000272",
    "HP_0000303",
    "HP_0000316"
];

// Creates a new treemap layout
var treemap = d3.treemap()
    .tile(d3.treemapResquarify) // This is the default with the golden ratio
    .size([width, height])
    .round(true) // Set rounding state to true to enable it. What does this mean?
    .paddingInner(2); // We can also set outer padding

// The principle behind d3.json() is to do everything in this function, 
// which will be executed when the json is loaded
d3.json("treemap.json", function(error, origData) {
    if (error) throw error;

    // This is the complete treemap.json raw data
	console.log("Complete raw treemap data:");
	console.log(origData);

    // https://github.com/d3/d3-hierarchy#node_sum
	var sumByCount = function(d) {
	    return d.children ? 0 : 1;
	};

    // This can be used to sum the IC score, why doesn't work?
    var sumByIc = function(d) {
	    return d.ic;
	};

    // This is used for calculating the matches
    // the number of matches will be stored in d.value
    var sumByMatch = function(d) {
        return (patientPhenotypes.indexOf(d.id) !== -1) ? 1 : 0;
    };

    // Constructs a root node from the specified hierarchical data. 
    // The specified data must be an object representing the root node. 
    var constructHierarchy = function(data, sum) {
        var rootNode = d3.hierarchy(data)
	        // https://github.com/d3/d3-hierarchy/blob/master/README.md#node_sum
	        // Must use sum before passing the hierarchy data to the treemap()
	        .sum(sum) 
	        .sort(function(a, b) { 
	        	// https://github.com/d3/d3-hierarchy/blob/master/README.md#node_sort
	            // sort nodes by descending height (greatest distance from any descendant leaf) and then descending value
	            return b.height - a.height || b.value - a.value; 
	        });

	    return rootNode;
    };

    // Render the treemap based on a given root data object
    var show = function(rootData, depth) {
        // Made a deep copy via jquery
        // so the input data will not be changed after applying d3.hierarchy
	    var copiedRootData = $.extend(true, {}, rootData);

	    // Constructs a root node from the specified hierarchical data
	    // The returned node and each descendant has the following properties: data, depth, height, parent, children, value
	    // We need to use the added properties d.depth to midify the structure
	    console.log("Constructing hierarchical data with d3 ...");
	    // Using sumByMatch aggregate the values (number of matches) for internal nodes
	    // so we can identify the nodes that cotain HP ids of the patient
	    var rootNode = constructHierarchy(copiedRootData, sumByMatch);

		console.log("D3 Hierarchy constructed data, before modification:");
		console.log(rootNode);

        // Deep copy of the subtree starting at this node via d3 built-in method
        // https://github.com/d3/d3-hierarchy#node_copy
        // So changes made to copiedRootNode won't affect rootNode
        var copiedRootNode = rootNode.copy();

        // Modify the children so they won't show up in the current rendering of treemap
	    // https://github.com/d3/d3-hierarchy/#node_each
	    copiedRootNode.each(function(d) { 
	        // Store the sumByMatch value for later highlighting
	        // No need to set d.value = null since we'll be using a different sum method shortly
	        d._value = d.value;
	        
	        // Hide all the children of depth 1 node, so we don't see them in treemap
	        if (d.depth === depth) {
				// Copy the data first
            	d._children = d.children;
		    	// Set to null so its children won't be rendered in treemap
		    	// Has to be null instead of empty array []
		    	d.children = null;
	        }
	    });
        
        console.log("D3 Hierarchy constructed data, after modification:");
		console.log(copiedRootNode);

        // Construct the new root node based on the modified copiedRootNode
        // Can't use subByMatch again here, since once apply treemap() 
        // we'll only see the nodes with matches.
        // But we still want to show all nodes and just highlight the matched ones
        // Once we have the IC scores, we may want to use sumByIc so the size of each rectangle 
        // will be determined by the summed IC score? Maybe?
		var newRootNode = constructHierarchy(copiedRootNode, sumByCount);

		console.log("newRootNode hierarchy........");
		console.log(newRootNode);

		// Deep copy, otherwise won't be able to see the changes in debugger
		var copiedNewRootNode = newRootNode.copy()

	    // Lays out the specified root hierarchy
	    // You must call root.sum before passing the hierarchy to the treemap layout. 
	    // Also assigns the following properties on root and its descendants: x0, y0, x1, y1
	    treemap(copiedNewRootNode);

        // Now treemap assigns the following properties on copiedNewRootNode and its descendants: x0, y0, x1, y1 
        // newRootNode stays unchanged, so we can compare the differences
		console.log("copiedNewRootNode with layout........");
		console.log(copiedNewRootNode);

        // Add the root data to nav array
        // Only add this new data if it doesn't exist
        if (navArr.indexOf(copiedNewRootNode.data.data) === -1) {
            navArr.push(copiedNewRootNode.data.data);
        }

        // Make sure the svg is empty before adding anything
        svg.selectAll("*").remove();

        // Create navigation bar
        // We may also use this to render a path from root to matched node
        // and this matched node can either be a leaf of internal node
        var nav = svg.selectAll(".nav")
            .data(navArr)
            .enter().append("g")
            .attr("class", "nav")
            .append("text")
            .attr("x", function(d, i) {
            	return (i > 0) ? i*80 : 0;
            })
            .attr("y", 20)
            .text(function(d, i) {
            	return (i > 0) ? " > " + d.id : d.id;
            })
            .on("click", function(d, i) {
            	// Remove all sub level data from the navArr
                navArr = navArr.slice(0, i);
            	// Then rerender the treemap
            	show(d, depth);
            });

        // Node
	    var node = svg.selectAll(".node")
	        .data(copiedNewRootNode.leaves())// Use the newRoot to render
	        .enter().append("g")
	        .attr("transform", function(d) { 
	        	// Add 40px to y so we can see the nav bar
	        	return "translate(" + d.x0 + "," + (d.y0 + 40) + ")"; 
	        });

        // Node rectangle
	    node.append("rect")
	        .attr("class", "node")
			.attr("id", function(d) { return d.data.data.id; })
			.attr("width", function(d) { return d.x1 - d.x0; })
			.attr("height", function(d) { return d.y1 - d.y0; })
			.attr("fill", function(d) { 
				// Highlight the node with matches with a different background color
				// d.data._value stores the sum from sumByMatch, which means
				// this node contains matched HP terms of the patient
				return (d.data._value > 0) ? "rgb(169, 133, 202)" : "#ddd"; 
			})
			.on('click', function(d) {
                // Only show drill down if has _children (after toggle)
                if (typeof(d.data._children) !== 'undefined' && d.data._children.length > 0) {
                    // Drill down one more level
                    // d.data.data contains all the origional data so we just use it directly
                    // Note: with the new root, its depth is back to 0 again
                    // So we just need to use 1
                    show(d.data.data, depth);
                } else {
                	alert("This node has no child, it's a leaf node");
                }
            });

	    // Text of each rectangle
	    node.append("text")
	        .attr("class", "node-name")
	        .selectAll("tspan")
	        .data(function(d) { 
	        	// Add [HP_Id] at the beginning of the label
	        	var idArr = ['[' + d.data.data.id + ']'];
	        	// Split the whole name into individual words
	        	var nameArr = d.data.data.name.split(' '); 
                
                // Join two arrays
                return idArr.concat(nameArr);
	        }) // Id + one word per line
	        .enter().append("tspan")
	        .attr("x", 5)
	        .attr("y", function(d, i) { return 15 + i * 10; }) // Increment the y of each line
	        .text(function(d) { 
	            return d; 
	        });

	    // Show title toltip (full phenotype name and [id]) on mouse over. 
	    node.append("title")
	        .text(function(d) { return d.data.data.name + ' [' + d.data.data.id + ']'; });
    };



    // Show all the 1st level categories of the root as the starting page
    // Root has a depth of 0, so we use 1 to show its direct subclasses
    // Nodes that contain matches will be highlighted in a different background color
    show(origData, 1);

});



</script>

</body>

</html>