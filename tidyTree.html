<!DOCTYPE html>
<head>
<style>

svg {
font: 10px sans-serif;
}

</style>

<script src="https://d3js.org/d3.v4.min.js"></script>
</head>

<body>

<svg id= "hpSvg" width="960" height="960"></svg>

<script>

var width = 960;
var height = 960;

var svg = d3.select("#hpSvg")
    .attr("width", width)
    .attr("height", height)
    .append("g")
    .attr("transform", "translate(" + (width / 2 + 40) + "," + (height / 2 + 40) + ")");

// Creates a new tree layout 
var tree = d3.tree()
    .size([width, height])
    .separation(function(a, b) { return (a.parent == b.parent ? 1 : 2) / a.depth; });

// A list of HP Ids from a patient with undiagnoised disease
var patientPhenotypes = [
    "HP_0012537",
    "HP_0000174",
    "HP_0000194",
    "HP_0000218",
    "HP_0000238",
    "HP_0000244",
    "HP_0000272",
    "HP_0000303",
    "HP_0000316"
];

d3.json("hp/hp_treemap.json", function(error, rootData) {
  	if (error) throw error;
    
    console.log(rootData);

    // Constructs a root node from the specified hierarchical data. 
    // The specified data must be an object representing the root node. 
    var constructRootNode = function(data, sum) {
        var rootNode = d3.hierarchy(data)
	        // https://github.com/d3/d3-hierarchy/blob/master/README.md#node_sum
	        // Must use sum before passing the hierarchy data to the treemap()
	        .sum(sum) 
            // https://github.com/d3/d3-hierarchy/blob/master/README.md#node_sort
	        .sort(function(a, b) { 	
	            // sort nodes by descending height (greatest distance from any descendant leaf) and then descending value
	            return b.height - a.height || b.value - a.value; 
	        });
        
        // The returned node and each descendant has the following added properties: 
        // data, depth, height, parent, children, value
	    return rootNode;
    };

    // Modify the provided root data by adding maching info
    var calculateMatch = function(rootData) {
        // This is used for calculating the matches
        // the number of matches will be stored in d.value
        var sumByMatch = function(d) {
            return (patientPhenotypes.indexOf(d.id) !== -1) ? 1 : 0;
        };

        // Constructs a root node from the specified hierarchical data
	    // Using sumByMatch aggregate the values (number of matches)
	    // so we can identify the nodes that contain matches(HP ids of the patient)
	    var rootNode = constructRootNode(rootData, sumByMatch);

        // Inject the calculated match into data for later highlighting
	    // https://github.com/d3/d3-hierarchy/#node_each
	    rootNode.each(function(d) { 
	        // No need to set d.value = null since we'll be using a different sum method shortly
	        // and the d.value will be changed by then
	        d.data.matchCount = d.value;
            // Also mark the actual matching node
            d.data.isMatch = (patientPhenotypes.indexOf(d.data.id) !== -1) ? true : false
	    });

        console.log("Root data with matching count...");
        console.log(rootNode.data);

        // Return the modified rootNode.data instead of the D3 hierarchy rootNode
        // We'll use this rootNode.data as the new data to construct hierarchy 
        // with a different sum method later
	    return rootNode.data;
    };

    var project = function(x, y) {
		var angle = (x - 90) / 180 * Math.PI;
		var radius = y;
		return [radius * Math.cos(angle), radius * Math.sin(angle)];
	};

    // Add calculated matches to the rootData
	var rootDataWithMatch = calculateMatch(rootData);

    var rootNode = d3.hierarchy(rootDataWithMatch);

    
    tree(rootNode);

    console.log(rootNode);

	var link = svg.selectAll(".link")
	.data(rootNode.descendants().slice(1))
	.enter().append("path")
	  .attr("class", "link")
	  .attr("d", function(d) {
	    return "M" + project(d.x, d.y)
	        + "C" + project(d.x, (d.y + d.parent.y) / 2)
	        + " " + project(d.parent.x, (d.y + d.parent.y) / 2)
	        + " " + project(d.parent.x, d.parent.y);
	  });

	var node = svg.selectAll(".node")
		.data(rootNode.descendants())
		.enter().append("g")
		.attr("class", function(d) { return "node" + (d.children ? " node--internal" : " node--leaf"); })
		.attr("transform", function(d) { return "translate(" + project(d.x, d.y) + ")"; });

	node.append("circle")
		.attr("r", 2.5);

	node.append("text")
		.attr("dy", ".31em")
		.attr("x", function(d) { return d.x < 180 === !d.children ? 6 : -6; })
		.style("text-anchor", function(d) { return d.x < 180 === !d.children ? "start" : "end"; })
		.attr("transform", function(d) { return "rotate(" + (d.x < 180 ? d.x - 90 : d.x + 90) + ")"; })
		//.text(function(d) { return d.data.name; });

});


</script>

</body>

</html>