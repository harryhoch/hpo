<!DOCTYPE html>
<head>
<style>

svg {
font: 10px sans-serif;
}

.node-group {
  
}

.node-circle {
  cursor: pointer;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.node-label {
  font: 10px sans-serif;
}

.link {
  fill: none;
  stroke: #ccc;
  stroke-width: 1.5px;
}

</style>

<script src="https://d3js.org/d3.v4.min.js" type="application/javascript"></script>
</head>

<body>

<svg id= "hpSvg" width="960" height="960"></svg>

<script>

// Set the dimensions and margins of the diagram
var margin = {top: 20, right: 90, bottom: 30, left: 140};
var width = 1060 - margin.left - margin.right;
var height = 680 - margin.top - margin.bottom;

// append the svg object to the body of the page
// appends a 'group' element to 'svg'
// moves the 'group' element to the top left margin
var svg = d3.select("#hpSvg")
    .attr("width", width + margin.right + margin.left)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate("+ margin.left + "," + margin.top + ")");

// A list of HP Ids from a patient with undiagnoised disease
var patientPhenotypes = [
    "HP_0012537",
    "HP_0000174",
    "HP_0000194",
    "HP_0000218",
    "HP_0000238",
    "HP_0000244",
    "HP_0000272",
    "HP_0000303",
    "HP_0000316"
];

// Make rootNode a global variable
var rootNode;
var i = 0;
var duration = 750;

var rootBgColor = "rgb(152, 121, 176)";
var isMatchBgColor = "rgb(100, 163, 72)";
var hasMatchBgColor = "rgb(223, 134, 59)";
var hasNoMatchRegularBgColor = "rgb(176, 196, 222)";
var hasNoMatchLeafBgColor = "rgb(255, 255, 255)";

// Declares a tree layout and assigns the size
var tree = d3.tree()
	.size([height, width]);

// Modify the provided root data by adding maching info
var calculateMatch = function(rootData) {
    // This is used for calculating the matches
    // the number of matches will be stored in d.value
    var sumByMatch = function(d) {
        return (patientPhenotypes.indexOf(d.id) !== -1) ? 1 : 0;
    };
    
    // Constructs a root node from the specified hierarchical data
    // Using sumByMatch aggregate the values (number of matches)
    // so we can identify the nodes that contain matches(HP ids of the patient)
    // The returned node and each descendant has the following added properties: 
    // data, depth, height, parent, children, value
    var rootNode = d3.hierarchy(rootData)
        // https://github.com/d3/d3-hierarchy/blob/master/README.md#node_sum
        // Must use sum before passing the hierarchy data to the treemap()
        .sum(sumByMatch) 
        // https://github.com/d3/d3-hierarchy/blob/master/README.md#node_sort
        .sort(function(a, b) { 	
            // sort nodes by descending height (greatest distance from any descendant leaf) and then descending value
            return b.height - a.height || b.value - a.value; 
        });

    // Inject the calculated match into data for later highlighting
    // https://github.com/d3/d3-hierarchy/#node_each
    rootNode.each(function(d) { 
        // No need to set d.value = null since we'll be using a different sum method shortly
        // and the d.value will be changed by then
        d.data.matchCount = d.value;
        // Also mark the actual matching node
        d.data.isMatch = (patientPhenotypes.indexOf(d.data.id) !== -1) ? true : false
    });

    console.log("Root data with matching count...");
    console.log(rootNode.data);

    // Return the modified rootNode.data instead of the D3 hierarchy rootNode
    // We'll use this rootNode.data as the new data to construct hierarchy 
    // with a different sum method later
    return rootNode.data;
};


// The principle behind d3.json() is to do everything in this function, 
// which will be executed when the json is loaded
d3.json("hp/hp_treemap.json", function(error, rootData) {
    if (error) throw error;
    
    // Add calculated matches to the rootData
    var rootDataWithMatch = calculateMatch(rootData);

    // Assigns parent, children, height, data, depth, value
    rootNode = d3.hierarchy(rootDataWithMatch);

	// Why?
	rootNode.x0 = height / 2;
	rootNode.y0 = 0;

    // Collapse nodes with children from the second level
    rootNode.children.forEach(collapse);

    update(rootNode);	
});

d3.select(self.frameElement).style("height", "800px");

// Collapse the node and all its children
function collapse(d) {
	// By default, assume all nodes have no labels created
	// all nodes are expanded
	d.labelCreated = false;
	d.collapsed = false;
	// Only collapse nodes with children
	if (d.children) {
		d._children = d.children;
		d._children.forEach(collapse);
		d.children = null;
		// Add a flag
		// Leaf nodes don't have this flag
		d.collapsed = true;
		// Not leaf node
		d.leaf = false;
	} else {
		// Mark it as leaf node
		d.leaf = true;
	}
}

function update(source) {
	// Assigns the x and y position for the nodes
	// At this moment, rootNode is already the hierarchy
	var treeData = tree(rootNode);

	// Compute the new tree layout.
	var nodes = treeData.descendants();
	var links = treeData.descendants().slice(1);

	// Normalize for fixed-depth.
	// this multiplier factor is the width of the level.
	nodes.forEach(function(d) { 
		d.y = d.depth * 100;
	});

	// ****************** Nodes section ***************************

	// Update the nodes...
	var node = svg.selectAll('.node-group')
		.data(nodes, function(d) {
			return d.id || (d.id = ++i); 
		});

	// Enter any new modes at the parent's previous position.
	var nodeEnter = node.enter().append('g')
		.attr('class', 'node-group')
		.attr("id", function(d) {
			return d.data.id;
		})
		.attr("transform", function(d) {
			return "translate(" + source.y0 + "," + source.x0 + ")";
		})
		.on('click', click)
		.on('mouseover', mouseover)
		.on('mouseout', mouseout);

	// Add Circle for the node
	nodeEnter.append('circle')
		.attr('class', 'node-circle');
    
    // Filter out the root node and create its label on left
    nodeEnter.filter((function(d) {
        	// Find the root node
        	return (d.parent == null);
        }))
		.append('text')
		.attr("y", 3)
		.attr("x", -12)
		.attr("text-anchor", "end")
		.text(function(d) { 
			return d.data.name; 
		});

	// Update
	var nodeUpdate = nodeEnter.merge(node);

	// Transition to the proper position for the node
	nodeUpdate.transition()
		.duration(duration)
		.attr("transform", function(d) { 
			return "translate(" + d.y + "," + d.x + ")";
		});

	// Update the node attributes and style
	nodeUpdate.select('.node-circle')
		.attr('r', 6)
		.style("fill", function(d) {
			if (d.parent === null) {
                // Give root its own bg color
                return rootBgColor;
	    	} else {
	    	    // Here we only have 3 colors: isMatchBgColor, hasMatchBgColor, hasNoMatchRegularBgColor, and hasNoMatchLeafBgColor
		    	if (d.data.isMatch) {
	                return isMatchBgColor;
				} else {
					if (d.data.matchCount > 0) {
                        return hasMatchBgColor;
					} else {
						return d._children ? hasNoMatchRegularBgColor : hasNoMatchLeafBgColor;
					}
				}
	    	}
		});

	// Remove any exiting nodes
	var nodeExit = node.exit().transition()
		.duration(duration)
		.attr("transform", function(d) {
			return "translate(" + source.y + "," + source.x + ")";
		})
		.remove();

	// On exit reduce the node circles size to 0
	nodeExit.select('circle')
		.attr('r', 1e-6);

	// On exit reduce the opacity of text labels
	nodeExit.select('text')
		.style('fill-opacity', 1e-6);

	// ****************** links section ***************************

	// Update the links...
	var link = svg.selectAll('path.link')
		.data(links, function(d) { 
			return d.id; 
		});

	// Enter any new links at the parent's previous position.
	var linkEnter = link.enter().insert('path', "g")
		.attr("class", "link")
		.attr('d', function(d){
			var o = {x: source.x0, y: source.y0};
			return diagonal(o, o);
		});

	// UPDATE
	var linkUpdate = linkEnter.merge(link);

	// Transition back to the parent element position
	linkUpdate.transition()
		.duration(duration)
		.attr('d', function(d){ 
			return diagonal(d, d.parent);
		});

	// Remove any exiting links
	var linkExit = link.exit().transition()
		.duration(duration)
		.attr('d', function(d) {
			var o = {x: source.x, y: source.y};
			return diagonal(o, o);
		})
		.remove();

	// Store the old positions for transition.
	nodes.forEach(function(d) {
		d.x0 = d.x;
		d.y0 = d.y;
	});

	// Creates a curved (diagonal) path from parent to the child nodes
	function diagonal(s, d) {
		var path = `M ${s.y} ${s.x} C ${(s.y + d.y) / 2} ${s.x}, ${(s.y + d.y) / 2} ${d.x}, ${d.y} ${d.x}`;

		return path;
	}

	// Toggle children on click
	// Click event only applies to nodes with children
	// Note: we apply click event on the root node
	function click(d) {
		if (d.children) {
			// When d.children is set, it means this node is expanded
			// recurisively collapse its children
			collapse(d);
		} else {
			// When d.children is not set, it could be 
			// a collapsed node or a leaf node
			if (d._children) {
                d.children = d._children;
			    d._children = null;

			    // Mark this node as not collapsed
			    d.collapsed = false;
			} 
		}

		update(d);
	}

    // Create label text if there's not one
    // Don't apply mouseover on root node
	function mouseover(d) {
		// Need to avoid to creating this label every time on mouseover
		if (d.parent != null && !d.labelCreated) {
			d3.select(this).append('text')
				.attr("y", 3)
				.attr("x", function(d) {
					return (d.children || d._children) ? -12 : 12;
				})
				.attr("class", "node-label")
				.attr("text-anchor", function(d) {
					// Place label on left if node has children,
					// otherwise on right of the node
					return (d.children || d._children) ? "end" : "start";
				})
				.text(function(d) { 
					return d.data.name; 
				});

            // So we know this node has label created already
		    d.labelCreated = true;
		}
	}

    // For leaf nodes and nodes with children but collapsed, remove the label text
    // For nodes with children but expanded, leave the label there
    // Don't apply mouseout on root node
	function mouseout(d) {
	    if (d.parent != null) {
            // When mouseout, d.labelCreated must have been set as true,
		    // so no need to check it
		    if (d.leaf || (!d.leaf && d.collapsed)) {
		        // Remove label text
		        d3.select(this).select("text").remove();
		        // Reset the flag
			    d.labelCreated = false;
		    } 
	    }
	}

}

</script> 
</body>

</html>
