<!DOCTYPE html>
<head>
<style>

svg {
font: 10px sans-serif;
}

.node {
  cursor: pointer;
}

.node-circle {
  fill: #fff;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.node text {
  font: 10px sans-serif;
}

.link {
  fill: none;
  stroke: #ccc;
  stroke-width: 1.5px;
}

</style>

<script src="https://d3js.org/d3.v4.min.js" type="application/javascript"></script>
</head>

<body>

<svg id= "hpSvg" width="960" height="960"></svg>

<script>

// Set the dimensions and margins of the diagram
var margin = {top: 20, right: 90, bottom: 30, left: 90};
var width = 960 - margin.left - margin.right;
var height = 600 - margin.top - margin.bottom;

// append the svg object to the body of the page
// appends a 'group' element to 'svg'
// moves the 'group' element to the top left margin
var svg = d3.select("#hpSvg")
    .attr("width", width + margin.right + margin.left)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate("+ margin.left + "," + margin.top + ")");

// Make rootNode a global variable
var rootNode;
var i = 0;
var duration = 750;

// declares a tree layout and assigns the size
var tree = d3.tree()
            .size([height, width]);

// The principle behind d3.json() is to do everything in this function, 
// which will be executed when the json is loaded
d3.json("hp/hp_treemap.json", function(error, rootData) {
    if (error) throw error;

	// Assigns parent, children, height, data, depth, value
	rootNode = d3.hierarchy(rootData);
	// Why?
	rootNode.x0 = height / 2;
	rootNode.y0 = 0;

    // Collapse after the second level
    rootNode.children.forEach(collapse);

    update(rootNode);	
});

d3.select(self.frameElement).style("height", "800px");

// Collapse the node and all its children
function collapse(d) {
	if (d.children) {
		d._children = d.children;
		d._children.forEach(collapse);
		d.children = null;
	}
}

function update(source) {
	// Assigns the x and y position for the nodes
	// At this moment, rootNode is already the hierarchy
	var treeData = tree(rootNode);

	// Compute the new tree layout.
	var nodes = treeData.descendants();
	var links = treeData.descendants().slice(1);

	// Normalize for fixed-depth.
	// this multiplier factor is the width of the level.
	nodes.forEach(function(d) { 
		d.y = d.depth * 100;
	});

	// ****************** Nodes section ***************************

	// Update the nodes...
	var node = svg.selectAll('.node')
		.data(nodes, function(d) {
			return d.id || (d.id = ++i); 
		});

	// Enter any new modes at the parent's previous position.
	var nodeEnter = node.enter().append('g')
		.attr('class', 'node')
		.attr("transform", function(d) {
			return "translate(" + source.y0 + "," + source.x0 + ")";
		})
		.on('click', click)
		.on('mouseover', showLabel)
		.on('mouseout', removeLabel);

	// Add Circle for the node
	nodeEnter.append('circle')
		.attr('class', 'node-circle')
		.attr('r', 1e-6)
		.style("fill", function(d) {
			return d._children ? "lightsteelblue" : "#fff";
		});

	// Add labels for the nodes
	/* nodeEnter.append('text')
	.attr("dy", ".35em")
	.attr("x", function(d) {
	return d.children || d._children ? -13 : 13;
	})
	.attr("text-anchor", function(d) {
	return d.children || d._children ? "end" : "start";
	})
	.text(function(d) { return d.data.name; });*/

	// Update
	var nodeUpdate = nodeEnter.merge(node);

	// Transition to the proper position for the node
	nodeUpdate.transition()
		.duration(duration)
		.attr("transform", function(d) { 
			return "translate(" + d.y + "," + d.x + ")";
		});

	// Update the node attributes and style
	nodeUpdate.select('.node-circle')
		.attr('r', 10)
		.style("fill", function(d) {
			return d._children ? "lightsteelblue" : "#fff";
		})
		.attr('cursor', 'pointer');


	// Remove any exiting nodes
	var nodeExit = node.exit().transition()
		.duration(duration)
		.attr("transform", function(d) {
			return "translate(" + source.y + "," + source.x + ")";
		})
		.remove();

	// On exit reduce the node circles size to 0
	nodeExit.select('circle')
		.attr('r', 1e-6);

	// On exit reduce the opacity of text labels
	nodeExit.select('text')
		.style('fill-opacity', 1e-6);

	// ****************** links section ***************************

	// Update the links...
	var link = svg.selectAll('path.link')
		.data(links, function(d) { 
			return d.id; 
		});

	// Enter any new links at the parent's previous position.
	var linkEnter = link.enter().insert('path', "g")
		.attr("class", "link")
		.attr('d', function(d){
			var o = {x: source.x0, y: source.y0};
			return diagonal(o, o);
		});

	// UPDATE
	var linkUpdate = linkEnter.merge(link);

	// Transition back to the parent element position
	linkUpdate.transition()
		.duration(duration)
		.attr('d', function(d){ 
			return diagonal(d, d.parent);
		});

	// Remove any exiting links
	var linkExit = link.exit().transition()
		.duration(duration)
		.attr('d', function(d) {
			var o = {x: source.x, y: source.y};
			return diagonal(o, o);
		})
		.remove();

	// Store the old positions for transition.
	nodes.forEach(function(d) {
		d.x0 = d.x;
		d.y0 = d.y;
	});

	// Creates a curved (diagonal) path from parent to the child nodes
	function diagonal(s, d) {
		var path = `M ${s.y} ${s.x}
		C ${(s.y + d.y) / 2} ${s.x},
		${(s.y + d.y) / 2} ${d.x},
		${d.y} ${d.x}`;

		return path;
	}

	// Toggle children on click.
	function click(d) {
		if (d.children) {
			collapse(d);
			// d._children = d.children;
			//d.children = null;
		} else {
			d.children = d._children;
			d._children = null;
		}

		update(d);
	}

	//https://gist.github.com/sfrdmn/1437516
	function showLabel() {
		node.append('text')
			.attr("dy", ".35em")
			.attr("x", function(d) {
				return d.children || d._children ? -13 : 13;
			})
			.attr("text-anchor", function(d) {
				return d.children || d._children ? "end" : "start";
			})
			.text(function(d) { return d.data.name; });
	}

	function removeLabel() {
		var node = d3.select(this).select("text").remove();
	}
}

</script> 
</body>

</html>
