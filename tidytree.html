<!DOCTYPE html>
<head>
<style>

svg {
font: 10px sans-serif;
}

.node-group {
  
}

.node-circle {
  cursor: pointer;
  fill: #fff;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.node-label {
  font: 10px sans-serif;
}

.link {
  fill: none;
  stroke: #ccc;
  stroke-width: 1.5px;
}

</style>

<script src="https://d3js.org/d3.v4.min.js" type="application/javascript"></script>
</head>

<body>

<svg id= "hpSvg" width="960" height="960"></svg>

<script>

// Set the dimensions and margins of the diagram
var margin = {top: 20, right: 90, bottom: 30, left: 140};
var width = 1060 - margin.left - margin.right;
var height = 680 - margin.top - margin.bottom;

// append the svg object to the body of the page
// appends a 'group' element to 'svg'
// moves the 'group' element to the top left margin
var svg = d3.select("#hpSvg")
    .attr("width", width + margin.right + margin.left)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate("+ margin.left + "," + margin.top + ")");

// Make rootNode a global variable
var rootNode;
var i = 0;
var duration = 750;

// Declares a tree layout and assigns the size
var tree = d3.tree()
	.size([height, width]);

// The principle behind d3.json() is to do everything in this function, 
// which will be executed when the json is loaded
d3.json("hp/hp_treemap.json", function(error, rootData) {
    if (error) throw error;

	// Assigns parent, children, height, data, depth, value
	rootNode = d3.hierarchy(rootData);
	// Why?
	rootNode.x0 = height / 2;
	rootNode.y0 = 0;

    // Collapse after the second level
    rootNode.children.forEach(collapse);

    update(rootNode);	
});

d3.select(self.frameElement).style("height", "800px");

// Collapse the node and all its children
function collapse(d) {
	// By default, assume all nodes have no labels created
	// all nodes are expanded
	d.labelCreated = false;
	d.collapsed = false;

	// Only collapse nodes with children
	if (d.children) {
		d._children = d.children;
		d._children.forEach(collapse);
		d.children = null;

		// Add a flag
		// Leaf nodes don't have this flag
		d.collapsed = true;

		// Not leaf node
		d.leaf = false;
	} else {
		// Mark it as leaf node
		d.leaf = true;
	}
}

function update(source) {
	// Assigns the x and y position for the nodes
	// At this moment, rootNode is already the hierarchy
	var treeData = tree(rootNode);

	// Compute the new tree layout.
	var nodes = treeData.descendants();
	var links = treeData.descendants().slice(1);

	// Normalize for fixed-depth.
	// this multiplier factor is the width of the level.
	nodes.forEach(function(d) { 
		d.y = d.depth * 100;
	});

	// ****************** Nodes section ***************************

	// Update the nodes...
	var node = svg.selectAll('.node-group')
		.data(nodes, function(d) {
			return d.id || (d.id = ++i); 
		});


	// Enter any new modes at the parent's previous position.
	var nodeEnter = node.enter().append('g')
		.attr('class', 'node-group')
		.attr("id", function(d) {
			return d.data.id;
		})
		.attr("transform", function(d) {
			return "translate(" + source.y0 + "," + source.x0 + ")";
		})
		.on('click', click)
		.on('mouseover', mouseover)
		.on('mouseout', mouseout);

	// Add Circle for the node
	nodeEnter.append('circle')
		.attr('class', 'node-circle')
		.attr('r', 1e-6)
		.style("fill", function(d) {
			// Fill the circle of node with children
			// Leave it empty for leaf nodes
			return d._children ? "lightsteelblue" : "#fff";
		});

	// Add labels for the nodes
	/* nodeEnter.append('text')
	.attr("dy", ".35em")
	.attr("x", function(d) {
	return d.children || d._children ? -13 : 13;
	})
	.attr("text-anchor", function(d) {
	return d.children || d._children ? "end" : "start";
	})
	.text(function(d) { return d.data.name; });*/

	// Update
	var nodeUpdate = nodeEnter.merge(node);

	// Transition to the proper position for the node
	nodeUpdate.transition()
		.duration(duration)
		.attr("transform", function(d) { 
			return "translate(" + d.y + "," + d.x + ")";
		});

	// Update the node attributes and style
	nodeUpdate.select('.node-circle')
		.attr('r', 10)
		.style("fill", function(d) {
			return d._children ? "lightsteelblue" : "#fff";
		})
		.attr('cursor', 'pointer');


	// Remove any exiting nodes
	var nodeExit = node.exit().transition()
		.duration(duration)
		.attr("transform", function(d) {
			return "translate(" + source.y + "," + source.x + ")";
		})
		.remove();

	// On exit reduce the node circles size to 0
	nodeExit.select('circle')
		.attr('r', 1e-6);

	// On exit reduce the opacity of text labels
	nodeExit.select('text')
		.style('fill-opacity', 1e-6);

	// ****************** links section ***************************

	// Update the links...
	var link = svg.selectAll('path.link')
		.data(links, function(d) { 
			return d.id; 
		});

	// Enter any new links at the parent's previous position.
	var linkEnter = link.enter().insert('path', "g")
		.attr("class", "link")
		.attr('d', function(d){
			var o = {x: source.x0, y: source.y0};
			return diagonal(o, o);
		});

	// UPDATE
	var linkUpdate = linkEnter.merge(link);

	// Transition back to the parent element position
	linkUpdate.transition()
		.duration(duration)
		.attr('d', function(d){ 
			return diagonal(d, d.parent);
		});

	// Remove any exiting links
	var linkExit = link.exit().transition()
		.duration(duration)
		.attr('d', function(d) {
			var o = {x: source.x, y: source.y};
			return diagonal(o, o);
		})
		.remove();

	// Store the old positions for transition.
	nodes.forEach(function(d) {
		d.x0 = d.x;
		d.y0 = d.y;
	});

	// Creates a curved (diagonal) path from parent to the child nodes
	function diagonal(s, d) {
		var path = `M ${s.y} ${s.x} C ${(s.y + d.y) / 2} ${s.x}, ${(s.y + d.y) / 2} ${d.x}, ${d.y} ${d.x}`;

		return path;
	}

	// Toggle children on click
	// Click event only applies to nodes with children
	function click(d) {
		if (d.children) {
			// When d.children is set, it means this node is expanded
			// no we need to collapse it again
			collapse(d);
			// d._children = d.children;
			//d.children = null;
		} else {
			// When d.children is not set, it could be 
			// a collapsed node or a leaf node
			if (d._children) {
                d.children = d._children;
			    d._children = null;

			    // Mark this node is not collapsed
			    d.collapsed = false;
			} 
            
            // Do nothing to the leaf node
		}

		update(d);
	}

    // Create label text if there's not one
	function mouseover(d) {
		// Need to avoid to creating this label every time on mouseover
		if (!d.labelCreated) {
			d3.select(this).append('text')
				.attr("y", 2)
				.attr("x", function(d) {
					return (d.children || d._children) ? -15 : 15;
				})
				.attr("class", "node-label")
				.attr("text-anchor", function(d) {
					// Place label on left if node has children,
					// otherwise on right of the node
					return (d.children || d._children) ? "end" : "start";
				})
				.text(function(d) { 
					return d.data.name; 
				});

            // So we know this node has label created already
		    d.labelCreated = true;
		}
	}

    // For leaf nodes and nodes with children but collapsed, remove the label text
    // For nodes with children but expanded, leave the label there
	function mouseout(d) {
	    // When mouseout, d.labelCreated must have been set as true,
	    // so no need to check it
	    if (d.leaf || (!d.leaf && d.collapsed)) {
	        // Remove label text
	        d3.select(this).select("text").remove();
	        // Reset the flag
		    d.labelCreated = false;
	    } 
	}

}

</script> 
</body>

</html>
